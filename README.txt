POSTMORTEM - Ashton Gallistel

Hello! If you're reading this, I managed to submit it within the 5 minutes until midnight I started writing this, or I just pushed it after the deadline. Regardless, thank you for reading! Let's get to it.

I had a lot of trouble with this project, despite trying to plan it out a ton going in. I had planned out how to handle various different aspects, such as cards, the mouse, drawing entities, and more, in a way that would be far better than my frantic project 1 and 2. I decided on patterns to follow, what would be connected to what, and more. Starting off, the project actually went pretty smoothly, not accounting for me starting later than I had wished. However, much of it fell apart as I went along. The cards and mouse turned out really great in my opinion, with their files turning out by far the best, and being massive improvements over their project 1 and 2 equivalents. However, as the project got bigger I began encountering massive issues, most notably the game manager.

The game manager started out fine, acting as a centerpiece from which the whole game was controlled. However, it was by far the largest source of bugs and issues as I progressed, as many of the issues I had occurred in part due to it. Various functions throughout the entire program demanded access to both the game manager and info about specific game objects related to them, requiring me to either create overcomplicated code trying to access them solely from the game manager, or to also pass them along in the function, negating part of the point of the game manager and resulting in bloated parameter lists. In the end, I went with the latter, but I'm pretty sure there was a better way to resolve this issue had I looked more into it.

There was also the issue with the visual delay system, where the cards would be revealed and have their effects play out, followed by the score for each location displaying, with a small timed delay. I had planned to use a coroutine and event queue for this, as I was familiar with coroutines from C# and thought that they were present in Lua. However, when I attempted to try and implement them, it turned out they functioned differently and could not perform the delay effect like I had hoped. I spent most of today trying to figure out a way to implement similar functionality with a list of calls to functions, but couldn't figure out a good way to make it work. I debated trying to recreate the event queue system shown in the class example, but I lacked the time to properly implement it from scratch in the time left before submitting it. As such, I ended up scrapping it in order to prioritize wrapping up other basic functionality. In review, I heavily underestimated what was clearly an extremely large task that I should have either focused on sooner, or prioritized over other features.

Something I'm also sad I didn't include was the options regarding real players vs AI. I designed much of the code involving the players to account for whether the player was a human or an AI, with the remaining code being pretty straightforward to fix. However, I never was able to implement it, as I wanted to get the delay implemented first so that you could actually view an AI vs AI game. As I was unable to implement the delay in time, I was also unable to implement the real vs AI choice. It also would have required me to make a title screen, which would have been it's own challenge that I underestimated.

However, it's not all bad. As mentioned earlier, I'm actually very proud of how the mouse and card files turned out. I coded the mouse file from scratch at the very start of the assignment, and ended up almost never needing to return to it, as it functioned flawlessly. This is in great contrast to my mouse code from projects 1 and 2, which I had to constantly review and modify in order to get my program to function. The cards also turned out really well, with me implementing a subclass sandbox and a prototyping system. I feel that it functioned extremely well, as I only ever returned to the card.lua file to add more functions as needed, and the cardBehavior.lua file worked exactly as intended for the most part. I'm especially proud of how the cards function during the player's turn. They're able to drop it inside of any of the open slots, and as long as it's still their turn, they're free to move the card around or back to their hand, with the player's mana updating accordingly. I'm extremely happy with how smoothly it functions, and when playing it feels natural and handles extremely well. 

When considering the reasons why I had so much trouble with this project, a good chunk of them come down to time. I started later than I should have due to spending an extra week and a half on project 2, and was unable to turn in project 3 on time. That being said, a good portion of time issues likely came from me not properly managing my time, such as leaving the large delay system to the final day on top of other features. Had I done this project again, I would have prioritized doing it sooner, so that I could get it functional in time, and in turn been able to implement other features.

This project is also possibly the largest one I've ever made solo for school, in terms of the amount of files and lines of code written. Most of my other large projects were done either in groups, or were made in more advanced engines like Unity. This class was one of very few where I've had to write code manually handling mouse inputs and similar, rather than just having the engine handle it, and it's the only one where I've made a game of this scale. On one hand, I am glad I got experience with programming more basic functionality, but on the other I feel like it took up time that could have been better spent working on features and patterns unique to the project. The closest project to this one I can think of is the one I made for my Game AI class, and even that one was made with 4 people and I think had fewer, or at least about the same total lines.

As if I'd want to work on something like this again, it depends. I enjoy the concept of making a card game, collectible or otherwise, and would enjoy making another in the future. However, I would definitely be making it in Unity or a similarly advanced gaming engine rather than Lua, as attempting to make such an involved program, alongside the basic functionality of the mouse and entities, is a process I would prefer to avoid repeating. It's not impossible by any means, but I encountered so much difficulty and spent so much time trying to work on both in the same program that I'd rather just do it in a program where such functionality is already handled by the engine itself. That way, I can focus on the functionality that would be unique to the card game, rather than just coding basic game functionality.

In the end, it's clear that I underestimated the workload, and improperly managed my time. However, I still did learn a great deal about how to implement patterns such as subclass sandboxes and prototyping. Additionally, although I was unable to implement it properly myself, I do have a better grasp of the event queue pattern, even if just due to researching it a bunch while trying to finish.

Note: Also! You'll notice that the cards will sometimes glow when playing them. This is due to played card's effects happening. Blue highlights signal that the card's effect occurred, while cyan highlights signal that the card was hit with another's effect. This was meant to be part of the uncompleted delay system, but I left it in as it still somewhat communicated what happened during the turn.
(I also coded a similar effect where the location scores are displayed after a turn, but I didn't think to add it without the delay system before submitting... whoops)

Credits:
Just me (Ashton Gallistel)! I coded all files within the program. No sound effects, music, or art were included in this program.